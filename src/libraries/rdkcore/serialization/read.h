/*
 *    OpenRDK : OpenSource Robot Development Kit
 *    Copyright (C) 2007, 2008  Daniele Calisi, Andrea Censi (<first_name>.<last_name>@dis.uniroma1.it)
 *
 *    This program is free software: you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation, either version 3 of the License, or
 *    (at your option) any later version.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

#ifndef H_READ
#define H_READ

#include <string>
#include <iostream>
#include "utils.h"
#include <rdkcore/exceptions/exceptions.h>

namespace RDK2 { namespace Serialization {
	
	using namespace std;
	class Reader;

	/** 
	 * A Readable object is one that implements a deserialization procedure. 
	 */
	class Readable {
		public:
		/**
		 * The object must let the exceptions generated by the Reader to pass through, as the reader
		 * will take care of them.
		 *
		 * For de-serializing, the object must call on "r":
		 * 1) r->startReading("class name");
		 * 2) zero or more r->read_* functions.
		 * 3) r->endReading();
		 */
		virtual void read(Reader*r)  throw (ReadingException) = 0;
		virtual ~Readable() {};
	};
	
	class Reader {
		public:
			virtual Readable * deserialize(cstr) = 0;
			virtual void deserialize(cstr, Readable *) = 0;
			virtual ~Reader() {};
			
		public:
		/** Chiamato all'inizio; se 
		 nello stream c'� un oggetto di un tipo diverso, lancia un'eccezione*/
		virtual unsigned char startReading(cstr className) throw(ReadingException) = 0;
			
			virtual   uint8_t read_u8 (cstr name="") throw(ReadingException) = 0;
			virtual    int8_t read_i8 (cstr name="") throw(ReadingException) = 0;
			virtual   int16_t read_i16(cstr name="") throw(ReadingException) = 0;
			virtual   int32_t read_i32(cstr name="") throw(ReadingException) = 0;
			virtual float32_t read_f32(cstr name="") throw(ReadingException) = 0;
			virtual float64_t read_f64(cstr name="") throw(ReadingException) = 0;
			
			virtual void read_u8   (  uint8_t**, size_t* n, cstr name="") throw(ReadingException) =0;
			virtual void read_i8   (   int8_t**, size_t* n, cstr name="") throw(ReadingException) =0;
			virtual void read_i16  (  int16_t**, size_t* n, cstr name="") throw(ReadingException) =0;
			virtual void read_i32  (  int32_t**, size_t* n, cstr name="") throw(ReadingException) =0;
			virtual void read_f32  (float32_t**, size_t* n, cstr name="") throw(ReadingException) =0;
			virtual void read_f64  (float64_t**, size_t* n, cstr name="") throw(ReadingException) =0;

			virtual void readBytes (     void**, size_t* n, cstr name="") throw(ReadingException) =0;

			/** stringa tranquilla: */
			virtual std::string readString(cstr name="") throw(ReadingException) =0;
			
			/** Legge un oggetto */
			virtual void readObject(Readable*r, cstr name="") throw(ReadingException) = 0;

			/** Legge un oggetto determinando da solo il tipo (xml);
			* se non pu� (binario) lancia eccezione. */
			virtual Readable* readObject(cstr name="") throw(ReadingException) = 0;
		
		virtual void doneReading() throw(ReadingException) =0 ;
	
		virtual void error(cstr message) throw(ReadingException)=0;
	};
	
}} // namespace RDK2::Serialization

namespace RDK2 {
	using Serialization::Reader;
}

#endif
